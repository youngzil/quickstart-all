JVM内部原理
http://ifeve.com/jvm-internals/


http://blog.csdn.net/carolzhang8406/article/details/6705831
java提供finalize()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。
          (1).对象不一定会被回收。
       (2).垃圾回收不是析构函数。
       (3).垃圾回收只与内存有关。
       (4).垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。
       
       
finalize()方法是在GC进行内存回收，清除对象的时候调用，但是如果内存一直充足，就不会进行GC，也就不会调用finalize()方法，所以GC和finalize()都是不可靠的
GC的回收只与内存有关

finalize()方法不可靠表现2方面：
1、如果内存一直充足，就不会进行GC，也就不会调用finalize()方法
2、即使执行了finalize()方法，但是之后对象又被引用，就不会进行回收，后续再次回收的时候，就不会执行finalize()方法了，finalize()方法只执行一次


JVM GC垃圾回收算法：
http://blog.csdn.net/doc_sgl/article/details/46594975
判断对象是否存活一般有两种方式：
1.引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
2.可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。

在Java语言中，GC Roots包括：
1、虚拟机栈(栈帧中的本地变量表)中引用的对象；
2、本地方法栈中JNI引用的对象。原生方法栈（Native Method Stack）中 JNI 中引用的对象。
3、方法区中类静态属性实体引用的对象。
4、方法区中常量引用的对象。

堆：年轻代、年老代
方法区：持久代
年轻代（young）：一个Eden区，两个Survivor区，young generation的gc称为minor gc
年老代（tenured）：tenured generation的gc称为major gc，就是通常说的full gc
持久代（perm）：用于存放静态文件，如Java类、方法等，主要用于存放classloader信息，比如类信息和method信息



JVM 方法区回收小结：很多人习惯称方法区为永久代（hotspot以永久代来实现方法区）
java虚拟机规范中提到：可以不要求虚拟机在方法区实现垃圾收集。而且在方法区的垃圾回收“性价比”一般比较低。在堆中，尤其是在年轻的，一次垃圾回收一般可以回收70-95%的空间
方法区也会发生垃圾回收，只是效率和性价比较低。回收主要分为两部分内容：废弃常量、无用的类。
1、废弃常量的回收
回收常量与java堆的对象回收非常相似。“没有地方引用”
这与堆中对象的回收类似。以常量池的字符串为例，如果没有任何对象引用了此字符串，那么它就有可能被系统清理出常量池。
2、废弃类的回收
	此类回收条件较为苛刻，需要满足如下的3点：
	1、该类所有实例已被回收，即Java堆中不存在该类的任何实例
	2、加载该类的ClassLoader已经被回收
	3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
	满足这三点后，仅仅是“可以”回收，并非必然进行。

废弃类回收的控制参数
JVM提供了几个参数控制类回收：
-Xnoclassgc：关闭CLASS的垃圾回收功能
-verbose:class：在控制台查看类加载情况
-XX:+TraceClassLoading：查看类加载信息(诊断内存泄露很有用)
-XX:+TraceClassUnLoading ： 查看类卸载信息（FastDebug版的虚拟机才支持）(诊断内存泄露很有用)

在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。




Minor collections和Major collections 
Minor collection当young space被占满时执行。它比major collections快，因为minor collection仅仅检查major collection相应的一个子集对象。minor collection比major collection发生的频率高。
Major collection当tenured space被占满时执行。他会清理tenured和young。



http://blog.csdn.net/u014086926/article/details/52106589#
java对象的引用包括
  强引用，软引用，弱引用，虚引用
１.强引用
2.软引用（SoftReference）
3.弱引用（WeakReference）
4.虚引用（PhantomReference）
  
Java中提供这四种引用类型主要有两个目的：
第一是可以让程序员通过代码的方式决定某些对象的生命周期；
第二是有利于JVM进行垃圾回收。

强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。
被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。
如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

某个对象的可及性如何判断:
◆单条引用路径可及性判断:在这条路径中，最弱的一个引用决定对象的可及性。
◆多条引用路径可及性判断:几条路径中，最强的一条的引用决定对象的可及性。


https://www.cnblogs.com/dolphin0520/p/3613043.html
http://blog.csdn.net/zcw4237256/article/category/7397381
JVM内存模型
http://blog.csdn.net/zcw4237256/article/details/79042143
Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是： 
1. 程序计数器 ：程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。不会内存溢出
2. Java虚拟机栈(JVM Stack)：使用 递归方法的时候容易导致栈内存溢出的现象，由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。
3. 本地方法栈 ：本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。
存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。
当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。
4. 堆 
5. 方法区。方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。


程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。


在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。



1. 程序计数器 ：程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。
在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。
　　由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。
2. Java虚拟机栈(JVM Stack)：
存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。
使用 递归方法的时候容易导致栈内存溢出的现象
由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。
在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。
3. 本地方法栈 
4. 堆 
5. 方法区。
JVM 方法区回收小结：很多人习惯称方法区为永久代（hotspot以永久代来实现方法区）
java虚拟机规范中提到：可以不要求虚拟机在方法区实现垃圾收集。而且在方法区的垃圾回收“性价比”一般比较低。在堆中，尤其是在年轻的，一次垃圾回收一般可以回收70-95%的空间
方法区也会发生垃圾回收，只是效率和性价比较低。回收主要分为两部分内容：废弃常量、无用的类。
1、废弃常量的回收
回收常量与java堆的对象回收非常相似。“没有地方引用”
这与堆中对象的回收类似。以常量池的字符串为例，如果没有任何对象引用了此字符串，那么它就有可能被系统清理出常量池。
2、废弃类的回收
	此类回收条件较为苛刻，需要满足如下的3点：
	1、该类所有实例已被回收，即Java堆中不存在该类的任何实例
	2、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
	3、加载该类的ClassLoader已经被回收
	满足这三点后，仅仅是“可以”回收，并非必然进行。

废弃类回收的控制参数
JVM提供了几个参数控制类回收：
-Xnoclassgc：关闭CLASS的垃圾回收功能
-verbose:class：在控制台查看类加载情况
-XX:+TraceClassLoading：查看类加载信息(诊断内存泄露很有用)
-XX:+TraceClassUnLoading ： 查看类卸载信息（FastDebug版的虚拟机才支持）(诊断内存泄露很有用)



程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。 
注：但是，如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。 
线程私有。每条线程都有一个程序计数器。
是唯一一个不会出现OutOfMemoryError的内存区域。
生命周期随着线程的创建而创建，随着线程的结束而死亡。 

Java虚拟机栈(JVM Stack)和本地方法栈 
Java虚拟机栈是描述Java方法运行过程的内存模型。 
Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。
本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。
都会抛出StackOverFlowError和OutOfMemoryError异常。

注：StackOverFlowError和OutOfMemoryError的异同？ 
StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。 
而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。 

堆是用来存放对象的内存空间。 几乎所有的对象都存储在堆中。 
堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OutOfMemoryError。 
堆在虚拟机启动时创建，垃圾回收的主要场所。

方法区：
Java虚拟机规范中定义方法区是堆的一个逻辑部分。 方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。 
方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。

程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个的，都是线程私有。 
整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。
两个“栈”的功能类似，都是方法运行过程的内存模型。Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。
Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。
堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。
程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法区。并且他们的生命周期和所属的线程一样。 
而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法栈。并在JVM启动的时候就创建，JVM停止才销毁。
对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。

jvm:标记复制、标记清除、标记整理算法（垃圾回收）
http://blog.csdn.net/u010841296/article/details/50945390


http://blog.csdn.net/zcw4237256/article/details/79042308
如何确定某个对象是“垃圾”？
1、引用计数法
2、在Java中采取了 可达性分析法。该方法的基本思想是通过一系列的“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。

典型的垃圾收集算法
1.Copying（复制）算法：对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。
　　很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。
2.Mark-Sweep（标记-清除）算法：容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作
3.Mark-Compact（标记-整理）算法：在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。
4.Generational Collection（分代收集）算法：
分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。
新生代都采取Copying算法
老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法


典型的垃圾收集器
1.Serial/Serial Old
　　Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。

2.ParNew
　　ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。

3.Parallel Scavenge
　　Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。

4.Parallel Old
　　Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。

5.CMS
　　CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。

6.G1
　　G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。

对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。
如果新生代的Eden Space和From Space的空间不足，则会发起一次GC，如果进行了GC之后，Eden Space和From Space能够容纳该对象就放在Eden Space和From Space。
在GC的过程中，会将Eden Space和From  Space中的存活对象移动到To Space，然后将Eden Space和From Space进行清理。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。在进行了GC之后，使用的便是Eden space和To Space了，下次GC时会将存活对象复制到From Space，如此反复循环。
当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。
一般来说，大对象会被直接分配到老年代，所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组
当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和JVM的相关参数。


在执行机制上JVM提供了串行GC（Serial GC）、并行回收GC（Parallel Scavenge）和并行GC（ParNew）


JVM、垃圾回收、内存调优、常见参数
http://blog.csdn.net/u010305706/article/details/50978370


四、JVM内存调优
对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数，过多的GC和Full GC是会占用很多的系统资源（主要是CPU），影响系统的吞吐量。特别要关注Full GC，因为它会对整个堆进行整理，导致Full GC一般由于以下几种情况：

1、旧生代空间不足
    调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 
2、Pemanet Generation空间不足
    增大Perm Gen空间，避免太多静态对象 
    统计得到的GC后晋升到旧生代的平均大小大于旧生代剩余空间
    控制好新生代和旧生代的比例 
    
    
各部分比例不良设置会导致什么后果
1）新生代设置过小
    一是新生代GC次数非常频繁，增大系统消耗；二是导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发Full GC
2）新生代设置过大
    一是新生代设置过大会导致旧生代过小（堆总量一定），从而诱发Full GC；二是新生代GC耗时大幅度增加
    一般说来新生代占整个堆1/3比较合适
3）Survivor设置过小
    导致对象从eden直接到达旧生代，降低了在新生代的存活时间
4）Survivor设置过大
    导致eden过小，增加了GC频率
    另外，通过-XX:MaxTenuringThreshold=n来控制新生代存活时间，尽量让对象在新生代被回收

JVM提供两种较为简单的GC策略的设置方式
1）吞吐量优先
    JVM以吞吐量为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，来达到吞吐量指标。这个值可由-XX:GCTimeRatio=n来设置
2）暂停时间优先
    JVM以暂停时间为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由-XX:MaxGCPauseRatio=n来设置


JVM常见配置

堆设置
-Xms:初始堆大小
-Xmx:最大堆大小
-XX:NewSize=n:设置年轻代大小
-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
-XX:MaxPermSize=n:设置持久代大小

收集器设置
-XX:+UseSerialGC:设置串行收集器
-XX:+UseParallelGC:设置并行收集器
-XX:+UseParalledlOldGC:设置并行年老代收集器
-XX:+UseConcMarkSweepGC:设置并发收集器

垃圾回收统计信息
-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:filename

并行收集器设置
-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)

并发收集器设置
-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。

Java垃圾回收类型
这里有五种可以在应用里使用的垃圾回收类型。仅需要使用JVM开关就可以在我们的应用里启用垃圾回收策略。让我们一起来逐一了解：

1、Serial GC（-XX:+UseSerialGC）：Serial GC使用简单的标记、清除、压缩方法对年轻代和年老代进行垃圾回收，即Minor GC和Major GC。Serial GC在client模式（客户端模式）很有用，比如在简单的独立应用和CPU配置较低的机器。这个模式对占有内存较少的应用很管用。
2、Parallel GC（-XX:+UseParallelGC）：除了会产生N个线程来进行年轻代的垃圾收集外，Parallel GC和Serial GC几乎一样。这里的N是系统CPU的核数。我们可以使用 -XX:ParallelGCThreads=n 这个JVM选项来控制线程数量。并行垃圾收集器也叫throughput收集器。因为它使用了多CPU加快垃圾回收性能。Parallel GC在进行年老代垃圾收集时使用单线程。
3、Parallel Old GC（-XX:+UseParallelOldGC）：和Parallel GC一样。不同之处，Parallel Old GC在年轻代垃圾收集和年老代垃圾回收时都使用多线程收集。
4、并发标记清除（CMS）收集器（-XX:+UseConcMarkSweepGC)：CMS收集器也被称为短暂停顿并发收集器。它是对年老代进行垃圾收集的。CMS收集器通过多线程并发进行垃圾回收，尽量减少垃圾收集造成的停顿。CMS收集器对年轻代进行垃圾回收使用的算法和Parallel收集器一样。这个垃圾收集器适用于不能忍受长时间停顿要求快速响应的应用。可使用 -XX:ParallelCMSThreads=n JVM选项来限制CMS收集器的线程数量。
5、G1垃圾收集器（-XX:+UseG1GC) G1（Garbage First）：垃圾收集器是在Java 7后才可以使用的特性，它的长远目标时代替CMS收集器。G1收集器是一个并行的、并发的和增量式压缩短暂停顿的垃圾收集器。G1收集器和其他的收集器运行方式不一样，不区分年轻代和年老代空间。它把堆空间划分为多个大小相等的区域。当进行垃圾收集时，它会优先收集存活对象较少的区域，因此叫“Garbage First”。你可以在Oracle Garbage-FIrst收集器文档找到更多详细信息。


Java垃圾回收调优
Java垃圾回收调优应该是提升应用吞吐量的最后一个选择。在你发现应用由于长时间垃圾回收导致了应用性能下降、出现超时的时候，应该考虑Java垃圾收集调优。
如果你在日志里看到 java.lang.OutOfMemoryError: PermGen space错误，那么可以尝试使用 -XX:PermGen 和 -XX:MaxPermGen JVM选项去监控并增加Perm Gen内存空间。你也可以尝试使用-XX:+CMSClassUnloadingEnabled并查看使用CMS垃圾收集器的执行性能。
如果你看到了大量的Full GC操作，那么你应该尝试增大老年代的内存空间。
全面垃圾收集调优要花费大量的努力和时间，这里没有一尘不变的硬性调优规则。你需要去尝试不同的选项并且对这些选项进行对比，从而找出最适合自己应用的方案。



一次CMS GC问题排查过程（理解原理+读懂GC日志）
http://blog.csdn.net/endlu/article/details/51423996


CMS收集周期
CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停，它的收集周期是这样：
初始标记(CMS-initial-mark) -> 并发标记(CMS-concurrent-mark) -> 重新标记(CMS-remark) -> 并发清除(CMS-concurrent-sweep) ->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。
其中的1，3两个步骤需要暂停所有的应用程序线程的。第一次暂停从root对象开始标记存活的对象，这个阶段称为初始标记；第二次暂停是在并发标记之后， 暂停所有应用程序线程，重新标记并发标记阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致）。第一次暂停会比较短，第二次暂停通常会比较长，并且 remark这个阶段可以并行标记。



