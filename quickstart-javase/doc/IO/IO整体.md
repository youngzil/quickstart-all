Scalable IO in Java：http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf
李林峰的netty系列文章：http://www.infoq.com/cn/minibooks/netty-in-depth
BIO NIO AIO到底是什么鬼？看这篇文章就够了。https://mp.weixin.qq.com/s/KFzhayyAc8RMYMDTuyQXUg
https://github.com/zy475459736/On-the-Way/blob/master/NettySeries/网络传输模型.md


另外这个是蚂蚁开源的基于netty的实践通信框架，代码不多，很适合学习网络编程。也可以看下 https://github.com/alipay/sofa-bolt
用AIO写的框架，可以看下：https://git.oschina.net/smartboot/smart-socket



文件IO、网络IO
BIO、NIO、AIO

网络IO分为：BIO、NIO、AIO
BIO和NIO中都有文件IO


IO线程模型一直在演化，
1、由最开始的单线程模型，
2、到BIO方式的单线程接受请求线程池线程单个线程处理单个请求的读写事件，
3、再到NIO的单线程接受请求线程池里面的单个线程可以处理不同请求的读写事件，
4、还有个Leader-follower线程模型，其的出现是为了解决单线程接受请求线程池线程处理请求下线程上下文切换以及线程间通信数据拷贝的开销，并且不需要维护一个队列。
LeaderFollower线程上下文切换以及线程间通信数据拷贝的开销，直接在IO线程处理请求。


Reactor和Proactor：
http://blog.jobbole.com/59676/
Reactor：实现同步非阻塞IO，多路复用IO
Proactor：实现异步非阻塞，AIO


阻塞IO：阻塞着等待可读和读阻塞
非阻塞IO：只有读阻塞，准备数据时候非阻塞
IO复用模型：IO复用，默认是同步阻塞，可以设置为非阻塞
信号驱动IO：非阻塞
异步IO：异步非阻塞IO


是同步还是异步，关注的是任务完成时消息通知的方式。由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。
消息的三种通知机制：状态、通知和回调。前者低效，后两者高效、类似。

阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。
同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。

1、对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已，此时，这个线程可能也会处理其他的消息。还有一点，在这里先扩展下：
(a) 如果这个线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫做同步非阻塞；
(b) 如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做同步阻塞；
所以同步的实现方式会有两种：同步阻塞、同步非阻塞；同理，异步也会有两种实现：异步阻塞、异步非阻塞；

2、对于阻塞调用来说，则当前线程就会被挂起等待当前函数返回；
虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。


EPOLL事件有两种模型：
Level Triggered (LT)
Edge Triggered (ET)

LT：在LT模式下，无论fd是否有事件发生，或者还有一些事件没有处理完，每次调用epoll_wait时，总会得到该fd让你处理（只要有没事件没有处理，会一直通知你处理，直到你处理完为止，这样就保证了数据的不丢失）。
ET:在ET模式下，当有事件发生时，系统只会通知你一次，即在调用epoll_wait返回fd后，不管这个事件你处理还是没处理，处理完没有处理完，当再次调用epoll_wait时，都不会再返回该fd

操作系统在LT模式下维护的就绪队列大小相对于ET模式肯定大，且LT轮询所有的fd总比ET轮询的fd大。自然在性能上LT不如ET，但是在使用ET模式的时，需要循环调用recv,send等处理函数，得保证其事件处理完毕，这样也会带来开销且容易出错。
从 kernel 代码来看，ET/LT模式的处理逻辑几乎完全相同，差别仅在于 LT模式在 event 发生时不会将其从 ready list 中移除，略为增大了event 处理过程中 kernel space 中记录数据的大小。
         


用户空间与内核空间
现在操作系统都是采用虚拟存储器，对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。
操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。
为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。
针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。

进程切换
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换/任务切换/上下文切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。
从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
1、保存处理机上下文，包括程序计数器和其他寄存器。
2、更新PCB信息。
3、把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
4、选择另一个进程执行，并更新其PCB。
5、更新内存管理的数据结构。
6、恢复处理机上下文。
         
进程的阻塞
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。

文件描述符fd
文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。
文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。

缓存 IO
缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。

缓存 IO 的缺点：
数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。   
         
         
https://mp.weixin.qq.com/s/KFzhayyAc8RMYMDTuyQXUg    
一.什么是同步？什么是异步？
二.什么是阻塞？什么是非阻塞？
三.什么是阻塞IO？什么是非阻塞IO？
四.什么是同步IO？什么是异步IO？
五.五种IO模型
六.两种高性能IO设计模式           
         
1、同步和异步
同步就是：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；
异步就是：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。
java中的synchronized关键字联系起来进行类比。当多个线程同时访问一个变量时，每个线程访问该变量就是一个事件，对于同步来说，就是这些线程必须逐个地来访问该变量，一个线程在访问该变量的过程中，其他线程必须等待；而对于异步来说，就是多个线程不必逐个地访问该变量，可以同时进行访问。

2、阻塞和非阻塞：
　　阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；
　　非阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。
　　这就是阻塞和非阻塞的区别。也就是说阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。

同步和异步着重点在于多个任务的执行过程中，一个任务的执行是否会导致整个流程的暂时等待；
而阻塞和非阻塞着重点在于发出一个请求操作时，如果进行操作的条件不满足是否会返会一个标志信息告知条件不满足。        
  
3、阻塞IO和非阻塞IO         
通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。

　　当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：
　　1）查看数据是否就绪；
　　2）进行数据拷贝（将数据从内核空间拷贝到用户空间）。        
         
阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。

4、同步IO和异步IO模型
事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的：
　　对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程。
　　而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。

同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。


5、在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。

6、在传统的网络服务设计模式中，有两种比较经典的模式：
　　一种是多线程，一种是线程池。
　　对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件

因此便出现了下面的两种高性能IO设计模式：Reactor和Proactor。




  
         
         
         