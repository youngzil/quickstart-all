1、什么是事务（Transaction）
根据维基百科的定义，一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的：1）为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法；2）当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。简单来讲，事务的作用至少有两个：保证数据一致性，以及对数据进行隔离。

2、事务（Transaction）的特性
ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）

3、事务（Transaction）的隔离级别
SQL标准定义了4种事务隔离级别：读未提交，读已提交，可重复读，串行化
分别解决了：脏读、不可重复读、幻读
脏读：读取的是未提交的过期数据
不可重复读：两次读取的数据不一致
幻读：读取的记录数量不一致，增多或者减少

数据库事务的隔离级别有4个，由低到高依次为
Read uncommitted(未授权读取、读未提交)、可能出现脏读。也就是说事务B读取到了事务A未提交的数据。
Read committed（授权读取、读提交）、可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。
Repeatable read（可重复读取）、可能出现幻读
Serializable（序列化）


4、怎么实现ACID
http://tech.it168.com/a2016/0905/2900/000002900122.shtml
实现ACID的核心技术是并发控制和日志技术
并发控制：2PL、OCC、MVCC：保证并发操作的正确性
日志：Redo/Undo,WAL协议：保证故障场景下可恢复


https://www.zhihu.com/question/60278698
最简单的并发控制算法是2PL（2 Phase Locking），分为两阶段：
1）获得锁阶段；
2）释放锁阶段。
一般2PL被称为是悲观并发控制。

乐观并发控制OCC（ Optimistic Concurrency Control）。OCC假设事务会成功，开始事务时该读读，该写写，不加锁。只有到提交时做一下验证，验证这个事务是不是能够成功提交。 OCC分为三阶段：
1）Read Phase, 对于读，放到Read Set，对于写，把写记到临时副本，放到Write Set。因为写是写到临时区的，属于未提交结果，其它事务读不到（这点是和MVCC的重要区别）；
2）Validation Phase，重扫Read Set，Write Set，检验数据是否满足Isolation Level，如果满足则Commit，否则Abort；
3）WritePhase，或者叫做Commit Phase，把临时副本区的数据更新到数据库中，完成事务提交。

MVCC（Multiversion Concurrency Control）是另一种并发控制算法。MVCC为每条记录维护多个快照（Snapshot），通过起止两个时间戳（Begin Timestamp / End Timestamp）维护副本的可见性。
读写进行的不同操作如下：
Update，创建一个新的版本（Version）；
Delete，更新End Timestamp。
Read，通过起止时间戳判定记录是否对当前事务可见（OCC读不到未提交的记录，所以不需要做这个判断）。


innodb通过undo log和redo log来实现。事务中，每当执行一条SQL语句对数据产生了影响，就会记录下来与之相反的操作到undo log(撤销日志）中，例如，更新会记录之前的状态，删除会形成insert，添加会形成delete，一旦事务被回滚，则执行undo log中记录的操作，来完成恢复到之前的状态。这里是个 逻辑恢复哦！同时，每当执行一条事务中的SQL，会将操作记录到redo log中，此时事务一旦被提交，就将该redolog中的操作，持久化到磁盘上，数据就持久的记录下来了（ACID的D）。


WAL(Write Ahead Log)协议解析
Write Ahead Log Protocol
　　1、事务所引起的所有改动都要记录在日志中，在事务提交完成之前，所有的这些记录必须被写入硬盘；
　　2、一个数据库的缓冲页直到被记入日志后才能发生修改。直到缓冲页对应的日志被写入磁盘之后，该缓冲页才会存入磁盘；
　　3、当缓冲页被修改和日志被更新的时候，在也上必须加上互斥锁，以保证改动被记录到日志中的顺序与它发生的顺序是一致的。
　　以上规则的结果：
　　1、如果一条日志记录未被存入硬盘，则它可以被忽略，因为该日志中包含的改动一定属于未提交的事务。此外，这样的日志不能反映已持久化在数据库中的改动；
　　2、日志记录按顺序记录系统的改动。加锁协议（latch protocol）保证如果有对于同一页改动的两条日志记录，则两条记录的顺序反映对页发生改变的顺序。


https://blog.csdn.net/libo222/article/details/52469547
MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC

数据库的原子性和一致性的实现：
https://www.zhihu.com/question/30272728
为了保证事务操作的原子性，必须实现基于日志的REDO/UNDO机制

为了实现原子性，需要通过日志：将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性），再对所有到崩溃时尚未成功提交的事务进行UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。

原子性并不能完全保证一致性。在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。
为了保证并发情况下的一致性，引入了隔离性，实现隔离性原则上无非是两种类型的锁：

一种是悲观锁，即当前事务将所有涉及操作的对象加锁，操作完成后释放给其它对象使用。为了尽可能提高性能，发明了各种粒度（数据库级/表级/行级……）/各种性质（共享锁/排他锁/共享意向锁/排他意向锁/共享排他意向锁……）的锁。为了解决死锁问题，又发明了两阶段锁协议/死锁检测等一系列的技术。

一种是乐观锁，即不同的事务可以同时看到同一对象（一般是数据行）的不同历史版本。如果有两个事务同时修改了同一数据行，那么在较晚的事务提交时进行冲突检测。实现也有两种，一种是通过日志UNDO的方式来获取数据行的历史版本，一种是简单地在内存中保存同一数据行的多个历史版本，通过时间戳来区分。


原子性：一个事务内的所有SQL操作是一个整体。都执行成功才算整个事务成功。如果某个失败，则必须要会退到事务执行之前的状态，执行成功的SQL需要被撤销。innodb通过undo log和redo log来实现。事务中，每当执行一条SQL语句对数据产生了影响，就会记录下来与之相反的操作到undo log(撤销日志）中，例如，更新会记录之前的状态，删除会形成insert，添加会形成delete，一旦事务被回滚，则执行undo log中记录的操作，来完成恢复到之前的状态。这里是个 逻辑恢复哦！同时，每当执行一条事务中的SQL，会将操作记录到redo log中，此时事务一旦被提交，就将该redolog中的操作，持久化到磁盘上，数据就持久的记录下来了（ACID的D）。
PS：还有，undolog才是原子性的关键。提供redolog，应该主要目的是提升磁盘的IO开销吧，如果直接写入磁盘，IO开销，会很大。如果先将操作记录到redolog中，可以顺序的记录，批量的记录，再一起同步到磁盘上，速度会比直接写磁盘快些。 mysql在生成redolog时，会使用 innodb log buffer，先缓冲到内存中，再同步到redolog上。速度会更快另外关于，一致性，应该是个整体概念，保证所有的mysql对象（数据，索引，约束，日志，用户）在事务执行前后都具有完整的特性，应该是mysql所有的功能都为此服务吧



https://blog.csdn.net/ylforever/article/details/51048945
Two-phase locking(二阶段锁)
为确保一个事务完全隔离，最简单方法是在事务开始时申请锁，在事务结束时释放锁。这意味着，事务必须等待申请完所有需要的锁才开始运行，在执行过程中完全占用锁，结束时才统一释放。这种方案逻辑上没问题，但是会耗费很多时间在等待锁资源上。
一种更快一些的方案是Two-Phase Locking Protocol(在DB2和SQL Server中使用)。在这种方案中，一个事务被分解为两个阶段。
1、在growing phase（发展阶段），事务可以申请锁，不能释放锁。
2、在shrinking phase(收缩阶段)，事务可以释放锁(已经加锁处理过的数据，且不会再处理)，不能申请锁。

数据库事务隔离级别和锁的实现方式
https://blog.csdn.net/yangtianyu1218/article/details/51543634

